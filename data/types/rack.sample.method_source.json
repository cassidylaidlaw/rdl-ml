{"Rack::Cascade": {}, "Rack::Recursive": {"include": {"parameter_names": ["env", "path"], "ret_types": ["Array"], "meth_source": "    def include(env, path)\n      unless path.index(@script_name) == 0 && (path[@script_name.size] == ?/ ||\n                                               path[@script_name.size].nil?)\n        raise ArgumentError, \"can only include below #{@script_name}, not #{path}\"\n      end\n\n      env = env.merge(PATH_INFO => path,\n                      SCRIPT_NAME => @script_name,\n                      REQUEST_METHOD => GET,\n                      \"CONTENT_LENGTH\" => \"0\", \"CONTENT_TYPE\" => \"\",\n                      RACK_INPUT => StringIO.new(\"\"))\n      @app.call(env)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/recursive.rb", 48], "parameter_types": [["Hash"], ["Array"]]}, "initialize": {"parameter_names": ["app"], "ret_types": ["Object"], "meth_source": "    def initialize(app)\n      @app = app\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/recursive.rb", 33], "parameter_types": [["Object"]]}, "call": {"parameter_names": ["env"], "ret_types": ["Array"], "meth_source": "    def call(env)\n      dup._call(env)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/recursive.rb", 37], "parameter_types": [["Hash"]]}, "_call": {"parameter_names": ["env"], "ret_types": ["Array"], "meth_source": "    def _call(env)\n      @script_name = env[SCRIPT_NAME]\n      @app.call(env.merge(RACK_RECURSIVE_INCLUDE => method(:include)))\n    rescue ForwardRequest => req\n      call(env.merge(req.env))\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/recursive.rb", 41], "parameter_types": [["Hash"]]}}, "Rack::Session::Abstract::Persisted": {"make_request": {"parameter_names": ["env"], "ret_types": ["Object"], "meth_source": "        def make_request(env)\n          Rack::Request.new env\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 230], "parameter_types": [["Hash"]]}, "initialize": {"parameter_names": ["app", "options"], "ret_types": ["Object"], "meth_source": "        def initialize(app, options={})\n          @app = app\n          @default_options = self.class::DEFAULT_OPTIONS.merge(options)\n          @key = @default_options.delete(:key)\n          @cookie_only = @default_options.delete(:cookie_only)\n          initialize_sid\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 207], "parameter_types": [["Object"], ["Hash"]]}, "load_session": {"parameter_names": ["req"], "ret_types": ["Array"], "meth_source": "        def load_session(req)\n          sid = current_session_id(req)\n          sid, session = find_session(req, sid)\n          [sid, session || {}]\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 268], "parameter_types": [["Object"]]}, "set_cookie": {"parameter_names": ["request", "res", "cookie"], "ret_types": ["nil"], "meth_source": "        def set_cookie(request, res, cookie)\n          if request.cookies[@key] != cookie[:value] || cookie[:expires]\n            res.set_cookie_header =\n              Utils.add_cookie_to_header(res.set_cookie_header, @key, cookie)\n          end\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 361], "parameter_types": [["Object"], ["Object"], ["Hash"]]}, "extract_session_id": {"parameter_names": ["request"], "ret_types": ["String"], "meth_source": "        def extract_session_id(request)\n          sid = request.cookies[@key]\n          sid ||= request.params[@key] unless @cookie_only\n          sid\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 276], "parameter_types": [["Object"]]}, "delete_session": {"parameter_names": ["req", "sid", "options"], "ret_types": ["nil"], "meth_source": "        def delete_session(req, sid, options)\n          raise '#delete_session not implemented'\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 394], "parameter_types": [["Object"], ["String"], ["Hash"]]}, "initialize_sid": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "        def initialize_sid\n          @sidbits = @default_options[:sidbits]\n          @sid_secure = @default_options[:secure_random]\n          @sid_length = @sidbits / 4\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 234], "parameter_types": []}, "session_exists?": {"parameter_names": ["req"], "ret_types": ["Bool"], "meth_source": "        def session_exists?(req)\n          value = current_session_id(req)\n          value && !value.empty?\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 290], "parameter_types": [["Object"]]}, "prepare_session": {"parameter_names": ["req"], "ret_types": ["Object"], "meth_source": "        def prepare_session(req)\n          session_was               = req.get_header RACK_SESSION\n          session                   = session_class.new(self, req)\n          req.set_header RACK_SESSION, session\n          req.set_header RACK_SESSION_OPTIONS, @default_options.dup\n          session.merge! session_was if session_was\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 257], "parameter_types": [["Object"]]}}, "Rack::Multipart::Parser::Collector::MimePart": {"get_data": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "          def get_data\n            data = body\n            if filename == \"\"\n              # filename is blank which means no file has been selected\n              return\n            elsif filename\n              body.rewind if body.respond_to?(:rewind)\n\n              # Take the basename of the upload's original filename.\n              # This handles the full Windows paths given by Internet Explorer\n              # (and perhaps other broken user agents) without affecting\n              # those which give the lone filename.\n              fn = filename.split(/[\\/\\\\]/).last\n\n              data = {:filename => fn, :type => content_type,\n                      :name => name, :tempfile => body, :head => head}\n            elsif !filename && content_type && body.is_a?(IO)\n              body.rewind\n\n              # Generic multipart cases, not coming from a form\n              data = {:type => content_type,\n                      :name => name, :tempfile => body, :head => head}\n            end\n\n            yield data\n          end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 81], "parameter_types": []}}, "Rack::Utils::Context": {"recontext": {"parameter_names": ["app"], "ret_types": ["Object"], "meth_source": "      def recontext(app)\n        self.class.new(@for, app)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 424], "parameter_types": [["Object"]]}, "initialize": {"parameter_names": ["app_f", "app_r"], "ret_types": ["Object"], "meth_source": "      def initialize(app_f, app_r)\n        raise 'running context does not respond to #context' unless app_f.respond_to? :context\n        @for, @app = app_f, app_r\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 415], "parameter_types": [["Object"], ["Object"]]}, "for": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      attr_reader :for, :app\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 413], "parameter_types": []}, "app": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      attr_reader :for, :app\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 413], "parameter_types": []}, "call": {"parameter_names": ["env"], "ret_types": ["Object"], "meth_source": "      def call(env)\n        @for.context(env, @app)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 420], "parameter_types": [["Hash"]]}, "context": {"parameter_names": ["env", "app"], "ret_types": ["Object"], "meth_source": "      def context(env, app=@app)\n        recontext(app).call(env)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 428], "parameter_types": [["Hash"], ["Object"]]}}, "Rack::MockResponse": {"body": {"parameter_names": [], "ret_types": ["String"], "meth_source": "    def body\n      # FIXME: apparently users of MockResponse expect the return value of\n      # MockResponse#body to be a string.  However, the real response object\n      # returns the body as a list.\n      #\n      # See spec_showstatus.rb:\n      #\n      #   should \"not replace existing messages\" do\n      #     ...\n      #     res.body.should == \"foo!\"\n      #   end\n      super.join\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 178], "parameter_types": []}, "initialize": {"parameter_names": ["status", "headers", "body", "errors"], "ret_types": ["Object"], "meth_source": "    def initialize(status, headers, body, errors=StringIO.new(\"\"))\n      @original_headers = headers\n      @errors           = errors.string if errors.respond_to?(:string)\n\n      super(body, status, headers)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 163], "parameter_types": [["Integer"], ["Hash"], ["String"], ["Object"]]}, "empty?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "    def empty?\n      [201, 204, 205, 304].include? status\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 192], "parameter_types": []}, "match": {"parameter_names": ["other"], "ret_types": ["Object"], "meth_source": "    def match(other)\n      body.match other\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 174], "parameter_types": [["String or Regexp"]]}, "=~": {"parameter_names": ["other"], "ret_types": ["Integer"], "meth_source": "    def =~(other)\n      body =~ other\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 170], "parameter_types": [["Regexp"]]}}, "Rack::Multipart::UploadedFile": {"local_path": {"parameter_names": [], "ret_types": ["String"], "meth_source": "      def path\n        @tempfile.path\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/uploaded_file.rb", 19], "parameter_types": []}, "initialize": {"parameter_names": ["path", "content_type", "binary"], "ret_types": ["Object"], "meth_source": "      def initialize(path, content_type = \"text/plain\", binary = false)\n        raise \"#{path} file does not exist\" unless ::File.exist?(path)\n        @content_type = content_type\n        @original_filename = ::File.basename(path)\n        @tempfile = Tempfile.new([@original_filename, ::File.extname(path)], encoding: Encoding::BINARY)\n        @tempfile.binmode if binary\n        FileUtils.copy_file(path, @tempfile.path)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/uploaded_file.rb", 10], "parameter_types": [["String"], ["String"], ["Bool"]]}, "method_missing": {"parameter_names": ["method_name", "args", "block"], "ret_types": ["nil"], "meth_source": "      def method_missing(method_name, *args, &block) #:nodoc:\n        @tempfile.__send__(method_name, *args, &block)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/uploaded_file.rb", 28], "parameter_types": [["Object"], ["Array"], ["Proc"]]}, "original_filename": {"parameter_names": [], "ret_types": ["String"], "meth_source": "      attr_reader :original_filename\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/uploaded_file.rb", 5], "parameter_types": []}, "respond_to?": {"parameter_names": ["args"], "ret_types": ["Bool"], "meth_source": "      def respond_to?(*args)\n        super or @tempfile.respond_to?(*args)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/uploaded_file.rb", 24], "parameter_types": [["Array"]]}, "path": {"parameter_names": [], "ret_types": ["String"], "meth_source": "      def path\n        @tempfile.path\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/uploaded_file.rb", 19], "parameter_types": []}}, "Rack::Multipart::Parser::BoundedIO": {"initialize": {"parameter_names": ["io", "content_length"], "ret_types": ["Object"], "meth_source": "        def initialize(io, content_length)\n          @io             = io\n          @content_length = content_length\n          @cursor = 0\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 15], "parameter_types": [["Object"], ["Integer"]]}, "rewind": {"parameter_names": [], "ret_types": ["Integer"], "meth_source": "        def rewind\n          @io.rewind\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 44], "parameter_types": []}, "read": {"parameter_names": ["size"], "ret_types": ["String"], "meth_source": "        def read(size)\n          return if @cursor >= @content_length\n\n          left = @content_length - @cursor\n\n          str = if left < size\n                  @io.read left\n                else\n                  @io.read size\n                end\n\n          if str\n            @cursor += str.bytesize\n          else\n            # Raise an error for mismatching Content-Length and actual contents\n            raise EOFError, \"bad content body\"\n          end\n\n          str\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 21], "parameter_types": [["Integer"]]}, "eof?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "        def eof?; @content_length == @cursor; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 42], "parameter_types": []}}, "Rack::Lint::HijackWrapper": {"initialize": {"parameter_names": ["io"], "ret_types": ["Object"], "meth_source": "      def initialize(io)\n        @io = io\n        REQUIRED_METHODS.each do |meth|\n          assert(\"rack.hijack_io must respond to #{meth}\") { io.respond_to? meth }\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 505], "parameter_types": [["Object"]]}}, "Rack::Auth::Digest::Nonce": {"fresh?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "        def fresh?\n          !stale?\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/nonce.rb", 44], "parameter_types": []}, "initialize": {"parameter_names": ["timestamp", "given_digest"], "ret_types": ["Object"], "meth_source": "        def initialize(timestamp = Time.now, given_digest = nil)\n          @timestamp, @given_digest = timestamp.to_i, given_digest\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/nonce.rb", 24], "parameter_types": [["Time"], ["String"]]}, "digest": {"parameter_names": [], "ret_types": ["String"], "meth_source": "        def digest\n          ::Digest::MD5.hexdigest([ @timestamp, self.class.private_key ] * ':')\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/nonce.rb", 32], "parameter_types": []}, "to_s": {"parameter_names": [], "ret_types": ["String"], "meth_source": "        def to_s\n          [([ @timestamp, digest ] * ' ')].pack(\"m*\").strip\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/nonce.rb", 28], "parameter_types": []}, "valid?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "        def valid?\n          digest == @given_digest\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/nonce.rb", 36], "parameter_types": []}, "stale?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "        def stale?\n          !self.class.time_limit.nil? && (Time.now.to_i - @timestamp) > self.class.time_limit\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/nonce.rb", 40], "parameter_types": []}}, "Rack::MockRequest::FatalWarner": {"string": {"parameter_names": [], "ret_types": ["String"], "meth_source": "      def string\n        \"\"\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 38], "parameter_types": []}, "write": {"parameter_names": ["warning"], "ret_types": ["nil"], "meth_source": "      def write(warning)\n        raise FatalWarning, warning\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 31], "parameter_types": [["Object"]]}, "flush": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "      def flush\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 35], "parameter_types": []}, "puts": {"parameter_names": ["warning"], "ret_types": ["nil"], "meth_source": "      def puts(warning)\n        raise FatalWarning, warning\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 27], "parameter_types": [["Object"]]}}, "Rack::ForwardRequest": {"initialize": {"parameter_names": ["url", "env"], "ret_types": ["Object"], "meth_source": "    def initialize(url, env={})\n      @url = URI(url)\n      @env = env\n\n      @env[PATH_INFO] =       @url.path\n      @env[QUERY_STRING] =    @url.query  if @url.query\n      @env[HTTP_HOST] =       @url.host   if @url.host\n      @env[\"HTTP_PORT\"] =     @url.port   if @url.port\n      @env[RACK_URL_SCHEME] = @url.scheme if @url.scheme\n\n      super \"forwarding to #{url}\"\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/recursive.rb", 13], "parameter_types": [["String"], ["Hash"]]}}, "Rack::Multipart::Parser::Collector::TempfilePart": {"file?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "          def file?; true; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 115], "parameter_types": []}, "close": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "          def close; body.close; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 116], "parameter_types": []}}, "Rack::Auth::Digest::Request": {"digest?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "        def digest?\n          \"digest\" == scheme\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/request.rb", 13], "parameter_types": []}, "method_missing": {"parameter_names": ["sym", "args"], "ret_types": ["Object"], "meth_source": "        def method_missing(sym, *args)\n          return super unless params.has_key?(key = sym.to_s)\n          return params[key] if args.size == 0\n          raise ArgumentError, \"wrong number of arguments (#{args.size} for 0)\"\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/request.rb", 33], "parameter_types": [["Symbol"], ["Array"]]}, "nonce": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "        def nonce\n          @nonce ||= Nonce.parse(params['nonce'])\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/request.rb", 21], "parameter_types": []}, "respond_to?": {"parameter_names": ["sym", ""], "ret_types": ["Bool"], "meth_source": "        def respond_to?(sym, *)\n          super or params.has_key? sym.to_s\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/request.rb", 29], "parameter_types": [["Symbol"], ["Array"]]}, "correct_uri?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "        def correct_uri?\n          request.fullpath == uri\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/request.rb", 17], "parameter_types": []}, "params": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "        def params\n          @params ||= Params.parse(parts.last)\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/request.rb", 25], "parameter_types": []}, "method": {"parameter_names": [], "ret_types": ["String"], "meth_source": "        def method\n          @env[RACK_METHODOVERRIDE_ORIGINAL_METHOD] || @env[REQUEST_METHOD]\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/request.rb", 9], "parameter_types": []}}, "Rack::QueryParser::Params": {"key?": {"parameter_names": ["key"], "ret_types": ["Bool"], "meth_source": "      def key?(key)\n        @params.key?(key)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 170], "parameter_types": [["Object"]]}, "initialize": {"parameter_names": ["limit"], "ret_types": ["Object"], "meth_source": "      def initialize(limit)\n        @limit  = limit\n        @size   = 0\n        @params = {}\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 154], "parameter_types": [["Integer"]]}, "to_params_hash": {"parameter_names": [], "ret_types": ["Hash"], "meth_source": "      def to_params_hash\n        hash = @params\n        hash.keys.each do |key|\n          value = hash[key]\n          if value.kind_of?(self.class)\n            if value.object_id == self.object_id\n              hash[key] = hash\n            else\n              hash[key] = value.to_params_hash\n            end\n          elsif value.kind_of?(Array)\n            value.map! {|x| x.kind_of?(self.class) ? x.to_params_hash : x}\n          end\n        end\n        hash\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 174], "parameter_types": []}}, "Rack::MockRequest::FatalWarning": {}, "Rack::Multipart::Parser": {"handle_empty_content!": {"parameter_names": ["content", "eof"], "ret_types": ["Bool"], "meth_source": "      def handle_empty_content!(content, eof)\n        if content.nil? || content.empty?\n          raise EOFError if eof\n          return true\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 359], "parameter_types": [["String"], ["Bool"]]}, "rx": {"parameter_names": [], "ret_types": ["Regexp"], "meth_source": "      def rx; @rx; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 281], "parameter_types": []}, "consume_boundary": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "      def consume_boundary\n        while @buf.gsub!(/\\A([^\\n]*(?:\\n|\\Z))/, '')\n          read_buffer = $1\n          case read_buffer.strip\n          when full_boundary then return :BOUNDARY\n          when @end_boundary then return :END_BOUNDARY\n          end\n          return if @buf.empty?\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 283], "parameter_types": []}, "handle_mime_head": {"parameter_names": [], "ret_types": ["Symbol"], "meth_source": "      def handle_mime_head\n        if @buf.index(EOL + EOL)\n          i = @buf.index(EOL+EOL)\n          head = @buf.slice!(0, i+2) # First \\r\\n\n          @buf.slice!(0, 2)          # Second \\r\\n\n\n          content_type = head[MULTIPART_CONTENT_TYPE, 1]\n          if name = head[MULTIPART_CONTENT_DISPOSITION, 1]\n            name = Rack::Auth::Digest::Params::dequote(name)\n          else\n            name = head[MULTIPART_CONTENT_ID, 1]\n          end\n\n          filename = get_filename(head)\n\n          if name.nil? || name.empty?\n            name = filename || \"#{content_type || TEXT_PLAIN}[]\"\n          end\n\n          @collector.on_mime_head @mime_index, head, filename, content_type, name\n          @state = :MIME_BODY\n        else\n          :want_read\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 239], "parameter_types": []}, "handle_consume_token": {"parameter_names": [], "ret_types": ["Symbol"], "meth_source": "      def handle_consume_token\n        tok = consume_boundary\n        # break if we're at the end of a buffer, but not if it is the end of a field\n        if tok == :END_BOUNDARY || (@buf.empty? && tok != :BOUNDARY)\n          @state = :DONE\n        else\n          @state = :MIME_HEAD\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 229], "parameter_types": []}, "handle_mime_body": {"parameter_names": [], "ret_types": ["Symbol"], "meth_source": "      def handle_mime_body\n        if @buf =~ rx\n          # Save the rest.\n          if i = @buf.index(rx)\n            @collector.on_mime_body @mime_index, @buf.slice!(0, i)\n            @buf.slice!(0, 2) # Remove \\r\\n after the content\n          end\n          @state = :CONSUME_TOKEN\n          @mime_index += 1\n        else\n          :want_read\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 265], "parameter_types": []}, "full_boundary": {"parameter_names": [], "ret_types": ["String"], "meth_source": "      def full_boundary; @full_boundary; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 279], "parameter_types": []}, "initialize": {"parameter_names": ["boundary", "tempfile", "bufsize", "query_parser"], "ret_types": ["Object"], "meth_source": "      def initialize(boundary, tempfile, bufsize, query_parser)\n        @buf            = \"\".force_encoding(Encoding::ASCII_8BIT)\n\n        @query_parser   = query_parser\n        @params         = query_parser.make_params\n        @boundary       = \"--#{boundary}\"\n        @boundary_size  = @boundary.bytesize + EOL.size\n        @bufsize        = bufsize\n\n        @rx = /(?:#{EOL})?#{Regexp.quote(@boundary)}(#{EOL}|--)/n\n        @full_boundary = @boundary\n        @end_boundary = @boundary + '--'\n        @state = :FAST_FORWARD\n        @mime_index = 0\n        @collector = Collector.new tempfile\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 167], "parameter_types": [["String"], ["Object"], ["Integer"], ["Object"]]}, "on_read": {"parameter_names": ["content", "eof"], "ret_types": ["nil"], "meth_source": "      def on_read content, eof\n        handle_empty_content!(content, eof)\n        @buf << content\n        run_parser\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 184], "parameter_types": [["String"], ["Bool"]]}, "tag_multipart_encoding": {"parameter_names": ["filename", "content_type", "name", "body"], "ret_types": ["String"], "meth_source": "      def tag_multipart_encoding(filename, content_type, name, body)\n        name = name.to_s\n        encoding = Encoding::UTF_8\n\n        name.force_encoding(encoding)\n\n        return if filename\n\n        if content_type\n          list         = content_type.split(';')\n          type_subtype = list.first\n          type_subtype.strip!\n          if TEXT_PLAIN == type_subtype\n            rest         = list.drop 1\n            rest.each do |param|\n              k,v = param.split('=', 2)\n              k.strip!\n              v.strip!\n              v = v[1..-2] if v[0] == '\"' && v[-1] == '\"'\n              encoding = Encoding.find v if k == CHARSET\n            end\n          end\n        end\n\n        name.force_encoding(encoding)\n        body.force_encoding(encoding)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 330], "parameter_types": [["String"], ["String"], ["String"], ["String"]]}, "run_parser": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "      def run_parser\n        loop do\n          case @state\n          when :FAST_FORWARD\n            break if handle_fast_forward == :want_read\n          when :CONSUME_TOKEN\n            break if handle_consume_token == :want_read\n          when :MIME_HEAD\n            break if handle_mime_head == :want_read\n          when :MIME_BODY\n            break if handle_mime_body == :want_read\n          when :DONE\n            break\n          end\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 203], "parameter_types": []}, "get_filename": {"parameter_names": ["head"], "ret_types": ["String"], "meth_source": "      def get_filename(head)\n        filename = nil\n        case head\n        when RFC2183\n          params = Hash[*head.scan(DISPPARM).flat_map(&:compact)]\n\n          if filename = params['filename']\n            filename = $1 if filename =~ /^\"(.*)\"$/\n          elsif filename = params['filename*']\n            encoding, _, filename = filename.split(\"'\", 3)\n          end\n        when BROKEN_QUOTED, BROKEN_UNQUOTED\n          filename = $1\n        end\n\n        return unless filename\n\n        if filename.scan(/%.?.?/).all? { |s| s =~ /%[0-9a-fA-F]{2}/ }\n          filename = Utils.unescape(filename)\n        end\n\n        filename.scrub!\n\n        if filename !~ /\\\\[^\\\\\"]/\n          filename = filename.gsub(/\\\\(.)/, '\\1')\n        end\n\n        if encoding\n          filename.force_encoding ::Encoding.find(encoding)\n        end\n\n        filename\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 294], "parameter_types": [["String"]]}, "handle_fast_forward": {"parameter_names": [], "ret_types": ["Symbol"], "meth_source": "      def handle_fast_forward\n        if consume_boundary\n          @state = :MIME_HEAD\n        else\n          raise EOFError, \"bad content body\" if @buf.bytesize >= @bufsize\n          :want_read\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 220], "parameter_types": []}, "state": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      attr_reader :state\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 165], "parameter_types": []}, "result": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      def result\n        @collector.each do |part|\n          part.get_data do |data|\n            tag_multipart_encoding(part.filename, part.content_type, part.name, data)\n            @query_parser.normalize_params(@params, part.name, data, @query_parser.param_depth_limit)\n          end\n        end\n\n        MultipartInfo.new @params.to_params_hash, @collector.find_all(&:file?).map(&:body)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 190], "parameter_types": []}}, "Rack::Utils::HeaderHash": {"names": {"parameter_names": [], "ret_types": ["Hash"], "meth_source": "        def names\n          @names\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 506], "parameter_types": []}, "has_key?": {"parameter_names": ["k"], "ret_types": ["Bool"], "meth_source": "      def include?(k)\n        super || @names.include?(k.downcase)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 481], "parameter_types": [["String"]]}, "replace": {"parameter_names": ["other"], "ret_types": ["Object"], "meth_source": "      def replace(other)\n        clear\n        other.each { |k, v| self[k] = v }\n        self\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 499], "parameter_types": [["Object"]]}, "merge": {"parameter_names": ["other"], "ret_types": ["Object"], "meth_source": "      def merge(other)\n        hash = dup\n        hash.merge! other\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 494], "parameter_types": [["Object"]]}, "merge!": {"parameter_names": ["other"], "ret_types": ["Object"], "meth_source": "      def merge!(other)\n        other.each { |k, v| self[k] = v }\n        self\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 489], "parameter_types": [["Object"]]}, "each": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "      def each\n        super do |k, v|\n          yield(k, v.respond_to?(:to_ary) ? v.to_ary.join(\"\\n\") : v)\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 452], "parameter_types": []}, "key?": {"parameter_names": ["k"], "ret_types": ["Bool"], "meth_source": "      def include?(k)\n        super || @names.include?(k.downcase)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 481], "parameter_types": [["String"]]}, "to_hash": {"parameter_names": [], "ret_types": ["Hash"], "meth_source": "      def to_hash\n        hash = {}\n        each { |k,v| hash[k] = v }\n        hash\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 458], "parameter_types": []}, "initialize": {"parameter_names": ["hash"], "ret_types": ["Object"], "meth_source": "      def initialize(hash={})\n        super()\n        @names = {}\n        hash.each { |k, v| self[k] = v }\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 440], "parameter_types": [["Hash"]]}, "delete": {"parameter_names": ["k"], "ret_types": ["Object"], "meth_source": "      def delete(k)\n        canonical = k.downcase\n        result = super @names.delete(canonical)\n        result\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 475], "parameter_types": [["String"]]}, "include?": {"parameter_names": ["k"], "ret_types": ["Bool"], "meth_source": "      def include?(k)\n        super || @names.include?(k.downcase)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 481], "parameter_types": [["String"]]}, "initialize_copy": {"parameter_names": ["other"], "ret_types": ["nil"], "meth_source": "      def initialize_copy(other)\n        super\n        @names = other.names.dup\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 447], "parameter_types": [["Object"]]}, "member?": {"parameter_names": ["k"], "ret_types": ["Bool"], "meth_source": "      def include?(k)\n        super || @names.include?(k.downcase)\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/utils.rb", 481], "parameter_types": [["String"]]}}, "Rack::QueryParser": {"params_hash_has_key?": {"parameter_names": ["hash", "key"], "ret_types": ["Bool"], "meth_source": "    def params_hash_has_key?(hash, key)\n      return false if key =~ /\\[\\]/\n\n      key.split(/[\\[\\]]+/).inject(hash) do |h, part|\n        next h if part == ''\n        return false unless params_hash_type?(h) && h.key?(part)\n        h[part]\n      end\n\n      true\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 137], "parameter_types": [["Hash"], ["String"]]}, "unescape": {"parameter_names": ["s"], "ret_types": ["String"], "meth_source": "    def unescape(s)\n      Utils.unescape(s)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 149], "parameter_types": [["String"]]}, "new_depth_limit": {"parameter_names": ["param_depth_limit"], "ret_types": ["Object"], "meth_source": "    def new_depth_limit(param_depth_limit)\n      self.class.new @params_class, key_space_limit, param_depth_limit\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 127], "parameter_types": [["Integer"]]}, "key_space_limit": {"parameter_names": [], "ret_types": ["Integer"], "meth_source": "    attr_reader :key_space_limit, :param_depth_limit\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 19], "parameter_types": []}, "new_space_limit": {"parameter_names": ["key_space_limit"], "ret_types": ["Object"], "meth_source": "    def new_space_limit(key_space_limit)\n      self.class.new @params_class, key_space_limit, param_depth_limit\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 123], "parameter_types": [["Integer"]]}, "params_hash_type?": {"parameter_names": ["obj"], "ret_types": ["Bool"], "meth_source": "    def params_hash_type?(obj)\n      obj.kind_of?(@params_class)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 133], "parameter_types": [["Object"]]}, "parse_nested_query": {"parameter_names": ["qs", "d"], "ret_types": ["Hash"], "meth_source": "    def parse_nested_query(qs, d = nil)\n      return {} if qs.nil? || qs.empty?\n      params = make_params\n\n      (qs || '').split(d ? (COMMON_SEP[d] || /[#{d}] */n) : DEFAULT_SEP).each do |p|\n        k, v = p.split('='.freeze, 2).map! { |s| unescape(s) }\n\n        normalize_params(params, k, v, param_depth_limit)\n      end\n\n      return params.to_params_hash\n    rescue ArgumentError => e\n      raise InvalidParameterError, e.message\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 60], "parameter_types": [["String"], ["String"]]}, "initialize": {"parameter_names": ["params_class", "key_space_limit", "param_depth_limit"], "ret_types": ["Object"], "meth_source": "    def initialize(params_class, key_space_limit, param_depth_limit)\n      @params_class = params_class\n      @key_space_limit = key_space_limit\n      @param_depth_limit = param_depth_limit\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 21], "parameter_types": [["Class"], ["Integer"], ["Integer"]]}, "normalize_params": {"parameter_names": ["params", "name", "v", "depth"], "ret_types": ["Hash"], "meth_source": "    def normalize_params(params, name, v, depth)\n      raise RangeError if depth <= 0\n\n      name =~ %r(\\A[\\[\\]]*([^\\[\\]]+)\\]*)\n      k = $1 || ''.freeze\n      after = $' || ''.freeze\n\n      if k.empty?\n        if !v.nil? && name == \"[]\".freeze\n          return Array(v)\n        else\n          return\n        end\n      end\n\n      if after == ''.freeze\n        params[k] = v\n      elsif after == \"[\".freeze\n        params[name] = v\n      elsif after == \"[]\".freeze\n        params[k] ||= []\n        raise ParameterTypeError, \"expected Array (got #{params[k].class.name}) for param `#{k}'\" unless params[k].is_a?(Array)\n        params[k] << v\n      elsif after =~ %r(^\\[\\]\\[([^\\[\\]]+)\\]$) || after =~ %r(^\\[\\](.+)$)\n        child_key = $1\n        params[k] ||= []\n        raise ParameterTypeError, \"expected Array (got #{params[k].class.name}) for param `#{k}'\" unless params[k].is_a?(Array)\n        if params_hash_type?(params[k].last) && !params_hash_has_key?(params[k].last, child_key)\n          normalize_params(params[k].last, child_key, v, depth - 1)\n        else\n          params[k] << normalize_params(make_params, child_key, v, depth - 1)\n        end\n      else\n        params[k] ||= make_params\n        raise ParameterTypeError, \"expected Hash (got #{params[k].class.name}) for param `#{k}'\" unless params_hash_type?(params[k])\n        params[k] = normalize_params(params[k], after, v, depth - 1)\n      end\n\n      params\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 78], "parameter_types": [["Hash"], ["String"], ["String"], ["Integer"]]}, "param_depth_limit": {"parameter_names": [], "ret_types": ["Integer"], "meth_source": "    attr_reader :key_space_limit, :param_depth_limit\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 19], "parameter_types": []}, "parse_query": {"parameter_names": ["qs", "d", "unescaper"], "ret_types": ["Hash"], "meth_source": "    def parse_query(qs, d = nil, &unescaper)\n      unescaper ||= method(:unescape)\n\n      params = make_params\n\n      (qs || '').split(d ? (COMMON_SEP[d] || /[#{d}] */n) : DEFAULT_SEP).each do |p|\n        next if p.empty?\n        k, v = p.split('='.freeze, 2).map!(&unescaper)\n\n        if cur = params[k]\n          if cur.class == Array\n            params[k] << v\n          else\n            params[k] = [cur, v]\n          end\n        else\n          params[k] = v\n        end\n      end\n\n      return params.to_params_hash\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 32], "parameter_types": [["String"], ["String"], ["Proc"]]}, "make_params": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "    def make_params\n      @params_class.new @key_space_limit\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/query_parser.rb", 119], "parameter_types": []}}, "Rack::MethodOverride": {"allowed_methods": {"parameter_names": [], "ret_types": ["Array"], "meth_source": "    def allowed_methods\n      ALLOWED_METHODS\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/method_override.rb", 34], "parameter_types": []}, "initialize": {"parameter_names": ["app"], "ret_types": ["Object"], "meth_source": "    def initialize(app)\n      @app = app\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/method_override.rb", 9], "parameter_types": [["Object"]]}, "method_override": {"parameter_names": ["env"], "ret_types": ["String"], "meth_source": "    def method_override(env)\n      req = Request.new(env)\n      method = method_override_param(req) ||\n        env[HTTP_METHOD_OVERRIDE_HEADER]\n      method.to_s.upcase\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/method_override.rb", 25], "parameter_types": [["Hash"]]}, "call": {"parameter_names": ["env"], "ret_types": ["Object"], "meth_source": "    def call(env)\n      if allowed_methods.include?(env[REQUEST_METHOD])\n        method = method_override(env)\n        if HTTP_METHODS.include?(method)\n          env[RACK_METHODOVERRIDE_ORIGINAL_METHOD] = env[REQUEST_METHOD]\n          env[REQUEST_METHOD] = method\n        end\n      end\n\n      @app.call(env)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/method_override.rb", 13], "parameter_types": [["Hash"]]}, "method_override_param": {"parameter_names": ["req"], "ret_types": ["String"], "meth_source": "    def method_override_param(req)\n      req.POST[METHOD_OVERRIDE_PARAM_KEY]\n    rescue Utils::InvalidParameterError, Utils::ParameterTypeError\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/method_override.rb", 38], "parameter_types": [["Object"]]}}, "Rack::QueryParser::ParameterTypeError": {}, "Rack::Auth::Digest::Params": {"initialize": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "        def initialize\n          super()\n\n          yield self if block_given?\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/params.rb", 23], "parameter_types": []}, "to_s": {"parameter_names": [], "ret_types": ["String"], "meth_source": "        def to_s\n          map do |k, v|\n            \"#{k}=\" << (UNQUOTED.include?(k) ? v.to_s : quote(v))\n          end.join(', ')\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/params.rb", 39], "parameter_types": []}, "quote": {"parameter_names": ["str"], "ret_types": ["String"], "meth_source": "        def quote(str) # From WEBrick::HTTPUtils\n          '\"' << str.gsub(/[\\\\\\\"]/o, \"\\\\\\1\") << '\"'\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/params.rb", 45], "parameter_types": [["String"]]}}, "Rack::Builder": {"use": {"parameter_names": ["middleware", "args", "block"], "ret_types": ["nil"], "meth_source": "    def use(middleware, *args, &block)\n      if @map\n        mapping, @map = @map, nil\n        @use << proc { |app| generate_map app, mapping }\n      end\n      @use << proc { |app| middleware.new(app, *args, &block) }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 81], "parameter_types": [["Object"], ["Array"], ["Proc"]]}, "initialize": {"parameter_names": ["default_app", "block"], "ret_types": ["Object"], "meth_source": "    def initialize(default_app = nil, &block)\n      @use, @map, @run, @warmup = [], nil, default_app, nil\n      instance_eval(&block) if block_given?\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 53], "parameter_types": [["Object"], ["Proc"]]}, "generate_map": {"parameter_names": ["default_app", "mapping"], "ret_types": ["Object"], "meth_source": "    def generate_map(default_app, mapping)\n      mapped = default_app ? {'/' => default_app} : {}\n      mapping.each { |r,b| mapped[r] = self.class.new(default_app, &b).to_app }\n      URLMap.new(mapped)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 158], "parameter_types": [["Object"], ["Hash"]]}, "to_app": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "    def to_app\n      app = @map ? generate_map(@run, @map) : @run\n      fail \"missing run or map statement\" unless app\n      app = @use.reverse.inject(app) { |a,e| e[a] }\n      @warmup.call(app) if @warmup\n      app\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 144], "parameter_types": []}, "run": {"parameter_names": ["app"], "ret_types": ["nil"], "meth_source": "    def run(app)\n      @run = app\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 103], "parameter_types": [["Object"]]}, "call": {"parameter_names": ["env"], "ret_types": ["Object"], "meth_source": "    def call(env)\n      to_app.call(env)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 152], "parameter_types": [["Hash"]]}, "map": {"parameter_names": ["path", "block"], "ret_types": ["nil"], "meth_source": "    def map(path, &block)\n      @map ||= {}\n      @map[path] = block\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 139], "parameter_types": [["String"], ["Proc"]]}, "warmup": {"parameter_names": ["prc", "block"], "ret_types": ["Object"], "meth_source": "    def warmup(prc=nil, &block)\n      @warmup = prc || block\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/builder.rb", 116], "parameter_types": [["Proc"], ["Proc"]]}}, "Rack::QueryParser::InvalidParameterError": {}, "Rack::Logger": {"initialize": {"parameter_names": ["app", "level"], "ret_types": ["Object"], "meth_source": "    def initialize(app, level = ::Logger::INFO)\n      @app, @level = app, level\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/logger.rb", 6], "parameter_types": [["Object"], ["Integer"]]}, "call": {"parameter_names": ["env"], "ret_types": ["Object"], "meth_source": "    def call(env)\n      logger = ::Logger.new(env[RACK_ERRORS])\n      logger.level = @level\n\n      env[RACK_LOGGER] = logger\n      @app.call(env)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/logger.rb", 10], "parameter_types": [["Hash"]]}}, "Rack::NullLogger": {"debug?": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def debug? ; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 19], "parameter_types": []}, "error?": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def error? ; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 21], "parameter_types": []}, "info?": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def info? ;  end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 18], "parameter_types": []}, "warn?": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def warn? ;  end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 20], "parameter_types": []}, "debug": {"parameter_names": ["progname", "block"], "ret_types": ["nil"], "meth_source": "    def debug(progname = nil, &block); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 13], "parameter_types": [["String"], ["Proc"]]}, "warn": {"parameter_names": ["progname", "block"], "ret_types": ["nil"], "meth_source": "    def warn(progname = nil, &block); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 14], "parameter_types": [["String"], ["Proc"]]}, "add": {"parameter_names": ["severity", "message", "progname", "block"], "ret_types": ["nil"], "meth_source": "    def add(severity, message = nil, progname = nil, &block); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 34], "parameter_types": [["Integer"], ["String"], ["String"], ["Proc"]]}, "initialize": {"parameter_names": ["app"], "ret_types": ["nil"], "meth_source": "    def initialize(app)\n      @app = app\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 3], "parameter_types": [["Object"]]}, "<<": {"parameter_names": ["msg"], "ret_types": ["nil"], "meth_source": "    def <<(msg); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 35], "parameter_types": [["String"]]}, "info": {"parameter_names": ["progname", "block"], "ret_types": ["nil"], "meth_source": "    def info(progname = nil, &block); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 12], "parameter_types": [["String"], ["Proc"]]}, "fatal": {"parameter_names": ["progname", "block"], "ret_types": ["nil"], "meth_source": "    def fatal(progname = nil, &block); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 16], "parameter_types": [["String"], ["Proc"]]}, "unknown": {"parameter_names": ["progname", "block"], "ret_types": ["nil"], "meth_source": "    def unknown(progname = nil, &block); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 17], "parameter_types": [["String"], ["Proc"]]}, "fatal?": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def fatal? ; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 22], "parameter_types": []}, "close": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def close ; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 33], "parameter_types": []}, "call": {"parameter_names": ["env"], "ret_types": ["nil"], "meth_source": "    def call(env)\n      env[RACK_LOGGER] = self\n      @app.call(env)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 7], "parameter_types": [["Hash"]]}, "error": {"parameter_names": ["progname", "block"], "ret_types": ["nil"], "meth_source": "    def error(progname = nil, &block); end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/null_logger.rb", 15], "parameter_types": [["String"], ["Proc"]]}}, "Rack::Multipart::Parser::Collector::BufferPart": {"file?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "          def file?; false; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 110], "parameter_types": []}, "close": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "          def close; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 111], "parameter_types": []}}, "Rack::Multipart::MultipartPartLimitError": {}, "Rack::Session::Abstract::ID": {"delete_session": {"parameter_names": ["req", "sid", "options"], "ret_types": ["nil"], "meth_source": "        def delete_session(req, sid, options)\n          destroy_session req.env, sid, options\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 429], "parameter_types": [["Object"], ["String"], ["Hash"]]}, "write_session": {"parameter_names": ["req", "sid", "session", "options"], "ret_types": ["String or Bool"], "meth_source": "        def write_session(req, sid, session, options)\n          set_session req.env, sid, session, options\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 422], "parameter_types": [["Object"], ["String"], ["Object"], ["Hash"]]}, "find_session": {"parameter_names": ["req", "sid"], "ret_types": ["Array"], "meth_source": "        def find_session(req, sid)\n          get_session req.env, sid\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/abstract/id.rb", 414], "parameter_types": [["Object"], ["String"]]}}, "Rack::MockRequest": {"put": {"parameter_names": ["uri", "opts"], "ret_types": ["Object"], "meth_source": "    def put(uri, opts={})     request(PUT, uri, opts)     end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 58], "parameter_types": [["String"], ["Hash"]]}, "initialize": {"parameter_names": ["app"], "ret_types": ["Object"], "meth_source": "    def initialize(app)\n      @app = app\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 52], "parameter_types": [["Object"]]}, "request": {"parameter_names": ["method", "uri", "opts"], "ret_types": ["Object"], "meth_source": "    def request(method=GET, uri=\"\", opts={})\n      env = self.class.env_for(uri, opts.merge(:method => method))\n\n      if opts[:lint]\n        app = Rack::Lint.new(@app)\n      else\n        app = @app\n      end\n\n      errors = env[RACK_ERRORS]\n      status, headers, body  = app.call(env)\n      MockResponse.new(status, headers, body, errors)\n    ensure\n      body.close if body.respond_to?(:close)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 64], "parameter_types": [["String"], ["String"], ["Hash"]]}, "patch": {"parameter_names": ["uri", "opts"], "ret_types": ["Object"], "meth_source": "    def patch(uri, opts={})   request(PATCH, uri, opts)   end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 59], "parameter_types": [["String"], ["Hash"]]}, "delete": {"parameter_names": ["uri", "opts"], "ret_types": ["Object"], "meth_source": "    def delete(uri, opts={})  request(DELETE, uri, opts)  end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 60], "parameter_types": [["String"], ["Hash"]]}, "options": {"parameter_names": ["uri", "opts"], "ret_types": ["Object"], "meth_source": "    def options(uri, opts={}) request(OPTIONS, uri, opts) end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 62], "parameter_types": [["String"], ["Hash"]]}, "get": {"parameter_names": ["uri", "opts"], "ret_types": ["Object"], "meth_source": "    def get(uri, opts={})     request(GET, uri, opts)     end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 56], "parameter_types": [["String"], ["Hash"]]}, "post": {"parameter_names": ["uri", "opts"], "ret_types": ["Object"], "meth_source": "    def post(uri, opts={})    request(POST, uri, opts)    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 57], "parameter_types": [["String"], ["Hash"]]}, "head": {"parameter_names": ["uri", "opts"], "ret_types": ["Object"], "meth_source": "    def head(uri, opts={})    request(HEAD, uri, opts)    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/mock.rb", 61], "parameter_types": [["String"], ["Hash"]]}}, "Rack::BodyProxy": {"initialize": {"parameter_names": ["body", "block"], "ret_types": ["Object"], "meth_source": "    def initialize(body, &block)\n      @body = body\n      @block = block\n      @closed = false\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/body_proxy.rb", 3], "parameter_types": [["Object"], ["Proc"]]}, "method_missing": {"parameter_names": ["method_name", "args", "block"], "ret_types": ["Object"], "meth_source": "    def method_missing(method_name, *args, &block)\n      super if :to_ary == method_name\n      @body.__send__(method_name, *args, &block)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/body_proxy.rb", 39], "parameter_types": [["Symbol"], ["Array"], ["Proc"]]}, "closed?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "    def closed?\n      @closed\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/body_proxy.rb", 27], "parameter_types": []}, "respond_to?": {"parameter_names": ["method_name", "include_all"], "ret_types": ["Bool"], "meth_source": "    def respond_to?(method_name, include_all=false)\n      case method_name\n      when :to_ary, 'to_ary'\n        return false\n      end\n      super or @body.respond_to?(method_name, include_all)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/body_proxy.rb", 9], "parameter_types": [["Symbol"], ["Bool"]]}, "each": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "    def each\n      @body.each { |body| yield body }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/body_proxy.rb", 35], "parameter_types": []}, "close": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def close\n      return if @closed\n      @closed = true\n      begin\n        @body.close if @body.respond_to? :close\n      ensure\n        @block.call\n      end\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/body_proxy.rb", 17], "parameter_types": []}}, "Rack::Multipart::Parser::MultipartInfo": {}, "Rack::Lint::InputWrapper": {"initialize": {"parameter_names": ["input"], "ret_types": ["Object"], "meth_source": "      def initialize(input)\n        @input = input\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 356], "parameter_types": [["Object"]]}, "rewind": {"parameter_names": ["args"], "ret_types": ["nil"], "meth_source": "      def rewind(*args)\n        assert(\"rack.input#rewind called with arguments\") { args.size == 0 }\n        assert(\"rack.input#rewind raised Errno::ESPIPE\") {\n          begin\n            @input.rewind\n            true\n          rescue Errno::ESPIPE\n            false\n          end\n        }\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 436], "parameter_types": [["Array"]]}, "gets": {"parameter_names": ["args"], "ret_types": ["String"], "meth_source": "      def gets(*args)\n        assert(\"rack.input#gets called with arguments\") { args.size == 0 }\n        v = @input.gets\n        assert(\"rack.input#gets didn't return a String\") {\n          v.nil? or v.kind_of? String\n        }\n        v\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 362], "parameter_types": [["Array"]]}, "close": {"parameter_names": ["args"], "ret_types": ["nil"], "meth_source": "      def close(*args)\n        assert(\"rack.input#close must not be called\") { false }\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 449], "parameter_types": [["Array"]]}, "read": {"parameter_names": ["args"], "ret_types": ["String"], "meth_source": "      def read(*args)\n        assert(\"rack.input#read called with too many arguments\") {\n          args.size <= 2\n        }\n        if args.size >= 1\n          assert(\"rack.input#read called with non-integer and non-nil length\") {\n            args.first.kind_of?(Integer) || args.first.nil?\n          }\n          assert(\"rack.input#read called with a negative length\") {\n            args.first.nil? || args.first >= 0\n          }\n        end\n        if args.size >= 2\n          assert(\"rack.input#read called with non-String buffer\") {\n            args[1].kind_of?(String)\n          }\n        end\n\n        v = @input.read(*args)\n\n        assert(\"rack.input#read didn't return nil or a String\") {\n          v.nil? or v.kind_of? String\n        }\n        if args[0].nil?\n          assert(\"rack.input#read(nil) returned nil on EOF\") {\n            !v.nil?\n          }\n        end\n\n        v\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 388], "parameter_types": [["Array"]]}, "each": {"parameter_names": ["args"], "ret_types": ["Array"], "meth_source": "      def each(*args)\n        assert(\"rack.input#each called with arguments\") { args.size == 0 }\n        @input.each { |line|\n          assert(\"rack.input#each didn't yield a String\") {\n            line.kind_of? String\n          }\n          yield line\n        }\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 421], "parameter_types": [["Array"]]}}, "Rack::Lint::ErrorWrapper": {"write": {"parameter_names": ["str"], "ret_types": ["Integer"], "meth_source": "      def write(str)\n        assert(\"rack.errors#write not called with a String\") { str.kind_of? String }\n        @error.write str\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 477], "parameter_types": [["String"]]}, "initialize": {"parameter_names": ["error"], "ret_types": ["Object"], "meth_source": "      def initialize(error)\n        @error = error\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 467], "parameter_types": [["Object"]]}, "flush": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      def flush\n        @error.flush\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 484], "parameter_types": []}, "puts": {"parameter_names": ["str"], "ret_types": ["nil"], "meth_source": "      def puts(str)\n        @error.puts str\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 472], "parameter_types": [["Object"]]}, "close": {"parameter_names": ["args"], "ret_types": ["nil"], "meth_source": "      def close(*args)\n        assert(\"rack.errors#close must not be called\") { false }\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 489], "parameter_types": [["Array"]]}}, "Rack::Server::Options": {"parse!": {"parameter_names": ["args"], "ret_types": ["Hash"], "meth_source": "      def parse!(args)\n        options = {}\n        opt_parser = OptionParser.new(\"\", 24, '  ') do |opts|\n          opts.banner = \"Usage: rackup [ruby options] [rack options] [rackup config]\"\n\n          opts.separator \"\"\n          opts.separator \"Ruby options:\"\n\n          lineno = 1\n          opts.on(\"-e\", \"--eval LINE\", \"evaluate a LINE of code\") { |line|\n            eval line, TOPLEVEL_BINDING, \"-e\", lineno\n            lineno += 1\n          }\n\n          opts.on(\"-b\", \"--builder BUILDER_LINE\", \"evaluate a BUILDER_LINE of code as a builder script\") { |line|\n            options[:builder] = line\n          }\n\n          opts.on(\"-d\", \"--debug\", \"set debugging flags (set $DEBUG to true)\") {\n            options[:debug] = true\n          }\n          opts.on(\"-w\", \"--warn\", \"turn warnings on for your script\") {\n            options[:warn] = true\n          }\n          opts.on(\"-q\", \"--quiet\", \"turn off logging\") {\n            options[:quiet] = true\n          }\n\n          opts.on(\"-I\", \"--include PATH\",\n                  \"specify $LOAD_PATH (may be used more than once)\") { |path|\n            (options[:include] ||= []).concat(path.split(\":\"))\n          }\n\n          opts.on(\"-r\", \"--require LIBRARY\",\n                  \"require the library, before executing your script\") { |library|\n            options[:require] = library\n          }\n\n          opts.separator \"\"\n          opts.separator \"Rack options:\"\n          opts.on(\"-s\", \"--server SERVER\", \"serve using SERVER (thin/puma/webrick/mongrel)\") { |s|\n            options[:server] = s\n          }\n\n          opts.on(\"-o\", \"--host HOST\", \"listen on HOST (default: localhost)\") { |host|\n            options[:Host] = host\n          }\n\n          opts.on(\"-p\", \"--port PORT\", \"use PORT (default: 9292)\") { |port|\n            options[:Port] = port\n          }\n\n          opts.on(\"-O\", \"--option NAME[=VALUE]\", \"pass VALUE to the server as option NAME. If no VALUE, sets it to true. Run '#{$0} -s SERVER -h' to get a list of options for SERVER\") { |name|\n            name, value = name.split('=', 2)\n            value = true if value.nil?\n            options[name.to_sym] = value\n          }\n\n          opts.on(\"-E\", \"--env ENVIRONMENT\", \"use ENVIRONMENT for defaults (default: development)\") { |e|\n            options[:environment] = e\n          }\n\n          opts.on(\"-D\", \"--daemonize\", \"run daemonized in the background\") { |d|\n            options[:daemonize] = d ? true : false\n          }\n\n          opts.on(\"-P\", \"--pid FILE\", \"file to store PID\") { |f|\n            options[:pid] = ::File.expand_path(f)\n          }\n\n          opts.separator \"\"\n          opts.separator \"Common options:\"\n\n          opts.on_tail(\"-h\", \"-?\", \"--help\", \"Show this message\") do\n            puts opts\n            puts handler_opts(options)\n\n            exit\n          end\n\n          opts.on_tail(\"--version\", \"Show version\") do\n            puts \"Rack #{Rack.version} (Release: #{Rack.release})\"\n            exit\n          end\n        end\n\n        begin\n          opt_parser.parse! args\n        rescue OptionParser::InvalidOption => e\n          warn e.message\n          abort opt_parser.to_s\n        end\n\n        options[:config] = args.last if args.last && !args.last.empty?\n        options\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 9], "parameter_types": [["Array"]]}, "handler_opts": {"parameter_names": ["options"], "ret_types": ["String"], "meth_source": "      def handler_opts(options)\n        begin\n          info = []\n          server = Rack::Handler.get(options[:server]) || Rack::Handler.default\n          if server && server.respond_to?(:valid_options)\n            info << \"\"\n            info << \"Server-specific options for #{server.name}:\"\n\n            has_options = false\n            server.valid_options.each do |name, description|\n              next if name.to_s.match(/^(Host|Port)[^a-zA-Z]/) # ignore handler's host and port options, we do our own.\n              info << \"  -O %-21s %s\" % [name, description]\n              has_options = true\n            end\n            return \"\" if !has_options\n          end\n          info.join(\"\\n\")\n        rescue NameError\n          return \"Warning: Could not find handler specified (#{options[:server] || 'default'}) to determine handler-specific options\"\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 106], "parameter_types": [["Hash"]]}}, "Rack::Multipart::Generator": {"dump": {"parameter_names": [], "ret_types": ["Hash"], "meth_source": "      def dump\n        return nil if @first && !multipart?\n        return flattened_params unless @first\n\n        flattened_params.map do |name, file|\n          if file.respond_to?(:original_filename)\n            ::File.open(file.path, 'rb') do |f|\n              f.set_encoding(Encoding::BINARY)\n              content_for_tempfile(f, file, name)\n            end\n          else\n            content_for_other(file, name)\n          end\n        end.join << \"--#{MULTIPART_BOUNDARY}--\\r\"\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/generator.rb", 12], "parameter_types": []}, "initialize": {"parameter_names": ["params", "first"], "ret_types": ["Object"], "meth_source": "      def initialize(params, first = true)\n        @params, @first = params, first\n\n        if @first && !@params.is_a?(Hash)\n          raise ArgumentError, \"value must be a Hash\"\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/generator.rb", 4], "parameter_types": [["Hash"], ["Bool"]]}, "content_for_other": {"parameter_names": ["file", "name"], "ret_types": ["String"], "meth_source": "      def content_for_other(file, name)\n<<-EOF\n--#{MULTIPART_BOUNDARY}\\r\nContent-Disposition: form-data; name=\"#{name}\"\\r\n\\r\n#{file}\\r\nEOF\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/generator.rb", 83], "parameter_types": [["Object"], ["String"]]}, "flattened_params": {"parameter_names": [], "ret_types": ["Hash"], "meth_source": "      def flattened_params\n        @flattened_params ||= begin\n          h = Hash.new\n          @params.each do |key, value|\n            k = @first ? key.to_s : \"[#{key}]\"\n\n            case value\n            when Array\n              value.map { |v|\n                Multipart.build_multipart(v, false).each { |subkey, subvalue|\n                  h[\"#{k}[]#{subkey}\"] = subvalue\n                }\n              }\n            when Hash\n              Multipart.build_multipart(value, false).each { |subkey, subvalue|\n                h[k + subkey] = subvalue\n              }\n            else\n              h[k] = value\n            end\n          end\n          h\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/generator.rb", 47], "parameter_types": []}, "content_for_tempfile": {"parameter_names": ["io", "file", "name"], "ret_types": ["String"], "meth_source": "      def content_for_tempfile(io, file, name)\n<<-EOF\n--#{MULTIPART_BOUNDARY}\\r\nContent-Disposition: form-data; name=\"#{name}\"; filename=\"#{Utils.escape(file.original_filename)}\"\\r\nContent-Type: #{file.content_type}\\r\nContent-Length: #{::File.stat(file.path).size}\\r\n\\r\n#{io.read}\\r\nEOF\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/generator.rb", 72], "parameter_types": [["Object"], ["Object"], ["String"]]}, "multipart?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "      def multipart?\n        multipart = false\n\n        query = lambda { |value|\n          case value\n          when Array\n            value.each(&query)\n          when Hash\n            value.values.each(&query)\n          when Rack::Multipart::UploadedFile\n            multipart = true\n          end\n        }\n        @params.values.each(&query)\n\n        multipart\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/generator.rb", 29], "parameter_types": []}}, "Rack::Auth::Digest::MD5": {"valid_nonce?": {"parameter_names": ["auth"], "ret_types": ["Bool"], "meth_source": "        def valid_nonce?(auth)\n          auth.nonce.valid?\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 93], "parameter_types": [["Object"]]}, "valid?": {"parameter_names": ["auth"], "ret_types": ["Bool"], "meth_source": "        def valid?(auth)\n          valid_opaque?(auth) && valid_nonce?(auth) && valid_digest?(auth)\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 81], "parameter_types": [["Object"]]}, "KD": {"parameter_names": ["secret", "data"], "ret_types": ["String"], "meth_source": "        def KD(secret, data)\n          H([secret, data] * ':')\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 108], "parameter_types": [["String"], ["String"]]}, "valid_digest?": {"parameter_names": ["auth"], "ret_types": ["Bool"], "meth_source": "        def valid_digest?(auth)\n          pw = @authenticator.call(auth.username)\n          pw && Rack::Utils.secure_compare(digest(auth, pw), auth.response)\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 97], "parameter_types": [["Object"]]}, "params": {"parameter_names": ["hash"], "ret_types": ["Object"], "meth_source": "        def params(hash = {})\n          Params.new do |params|\n            params['realm'] = realm\n            params['nonce'] = Nonce.new.to_s\n            params['opaque'] = H(opaque)\n            params['qop'] = QOP\n\n            hash.each { |k, v| params[k] = v }\n          end\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 66], "parameter_types": [["Hash"]]}, "valid_opaque?": {"parameter_names": ["auth"], "ret_types": ["Bool"], "meth_source": "        def valid_opaque?(auth)\n          H(opaque) == auth.opaque\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 89], "parameter_types": [["Object"]]}, "passwords_hashed?": {"parameter_names": [], "ret_types": ["Bool"], "meth_source": "        def passwords_hashed?\n          !!@passwords_hashed\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 33], "parameter_types": []}, "valid_qop?": {"parameter_names": ["auth"], "ret_types": ["Bool"], "meth_source": "        def valid_qop?(auth)\n          QOP == auth.qop\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 85], "parameter_types": [["Object"]]}, "initialize": {"parameter_names": ["app", "realm", "opaque", "authenticator"], "ret_types": ["Object"], "meth_source": "        def initialize(app, realm=nil, opaque=nil, &authenticator)\n          @passwords_hashed = nil\n          if opaque.nil? and realm.respond_to? :values_at\n            realm, opaque, @passwords_hashed = realm.values_at :realm, :opaque, :passwords_hashed\n          end\n          super(app, realm, &authenticator)\n          @opaque = opaque\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 24], "parameter_types": [["Object"], ["String or Hash"], ["String"], ["Proc"]]}, "md5": {"parameter_names": ["data"], "ret_types": ["String"], "meth_source": "        def md5(data)\n          ::Digest::MD5.hexdigest(data)\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 102], "parameter_types": [["String"]]}, "challenge": {"parameter_names": ["hash"], "ret_types": ["String"], "meth_source": "        def challenge(hash = {})\n          \"Digest #{params(hash)}\"\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 77], "parameter_types": [["Hash"]]}, "A1": {"parameter_names": ["auth", "password"], "ret_types": ["Object"], "meth_source": "        def A1(auth, password)\n          [ auth.username, auth.realm, password ] * ':'\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 112], "parameter_types": [["Object"], ["String"]]}, "call": {"parameter_names": ["env"], "ret_types": ["Object"], "meth_source": "        def call(env)\n          auth = Request.new(env)\n\n          unless auth.provided?\n            return unauthorized\n          end\n\n          if !auth.digest? || !auth.correct_uri? || !valid_qop?(auth)\n            return bad_request\n          end\n\n          if valid?(auth)\n            if auth.nonce.stale?\n              return unauthorized(challenge(:stale => true))\n            else\n              env['REMOTE_USER'] = auth.username\n\n              return @app.call(env)\n            end\n          end\n\n          unauthorized\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 37], "parameter_types": [["Hash"]]}, "digest": {"parameter_names": ["auth", "password"], "ret_types": ["String"], "meth_source": "        def digest(auth, password)\n          password_hash = passwords_hashed? ? password : H(A1(auth, password))\n\n          KD(password_hash, [ auth.nonce, auth.nc, auth.cnonce, QOP, H(A2(auth)) ] * ':')\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 120], "parameter_types": [["Object"], ["String"]]}, "H": {"parameter_names": ["data"], "ret_types": ["String"], "meth_source": "        def md5(data)\n          ::Digest::MD5.hexdigest(data)\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 102], "parameter_types": [["String"]]}, "A2": {"parameter_names": ["auth"], "ret_types": ["String"], "meth_source": "        def A2(auth)\n          [ auth.method, auth.uri ] * ':'\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/auth/digest/md5.rb", 116], "parameter_types": [["Object"]]}}, "Rack::Lint": {"check_status": {"parameter_names": ["status"], "ret_types": ["nil"], "meth_source": "    def check_status(status)\n      ## This is an HTTP status. When parsed as integer (+to_i+), it must be\n      ## greater than or equal to 100.\n      assert(\"Status must be >=100 seen as integer\") { status.to_i >= 100 }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 617], "parameter_types": [["Object"]]}, "check_hijack": {"parameter_names": ["env"], "ret_types": ["nil"], "meth_source": "    def check_hijack(env)\n      if env[RACK_IS_HIJACK]\n        ## If rack.hijack? is true then rack.hijack must respond to #call.\n        original_hijack = env[RACK_HIJACK]\n        assert(\"rack.hijack must respond to call\") { original_hijack.respond_to?(:call) }\n        env[RACK_HIJACK] = proc do\n          ## rack.hijack must return the io that will also be assigned (or is\n          ## already present, in rack.hijack_io.\n          io = original_hijack.call\n          HijackWrapper.new(io)\n          ##\n          ## rack.hijack_io must respond to:\n          ## <tt>read, write, read_nonblock, write_nonblock, flush, close,\n          ## close_read, close_write, closed?</tt>\n          ##\n          ## The semantics of these IO methods must be a best effort match to\n          ## those of a normal ruby IO or Socket object, using standard\n          ## arguments and raising standard exceptions. Servers are encouraged\n          ## to simply pass on real IO objects, although it is recognized that\n          ## this approach is not directly compatible with SPDY and HTTP 2.0.\n          ##\n          ## IO provided in rack.hijack_io should preference the\n          ## IO::WaitReadable and IO::WaitWritable APIs wherever supported.\n          ##\n          ## There is a deliberate lack of full specification around\n          ## rack.hijack_io, as semantics will change from server to server.\n          ## Users are encouraged to utilize this API with a knowledge of their\n          ## server choice, and servers may extend the functionality of\n          ## hijack_io to provide additional features to users. The purpose of\n          ## rack.hijack is for Rack to \"get out of the way\", as such, Rack only\n          ## provides the minimum of specification and support.\n          env[RACK_HIJACK_IO] = HijackWrapper.new(env[RACK_HIJACK_IO])\n          io\n        end\n      else\n        ##\n        ## If rack.hijack? is false, then rack.hijack should not be set.\n        assert(\"rack.hijack? is false, but rack.hijack is present\") { env[RACK_HIJACK].nil? }\n        ##\n        ## If rack.hijack? is false, then rack.hijack_io should not be set.\n        assert(\"rack.hijack? is false, but rack.hijack_io is present\") { env[RACK_HIJACK_IO].nil? }\n      end\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 520], "parameter_types": [["Hash"]]}, "verify_content_length": {"parameter_names": ["bytes"], "ret_types": ["nil"], "meth_source": "    def verify_content_length(bytes)\n      if @head_request\n        assert(\"Response body was given for HEAD request, but should be empty\") {\n          bytes == 0\n        }\n      elsif @content_length\n        assert(\"Content-Length header was #{@content_length}, but should be #{bytes}\") {\n          @content_length == bytes.to_s\n        }\n      end\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 686], "parameter_types": [["Integer"]]}, "check_content_type": {"parameter_names": ["status", "headers"], "ret_types": ["nil"], "meth_source": "    def check_content_type(status, headers)\n      headers.each { |key, value|\n        ## There must not be a <tt>Content-Type</tt>, when the +Status+ is 1xx,\n        ## 204, 205 or 304.\n        if key.downcase == \"content-type\"\n          assert(\"Content-Type header found in #{status} response, not allowed\") {\n            not Rack::Utils::STATUS_WITH_NO_ENTITY_BODY.include? status.to_i\n          }\n          return\n        end\n      }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 659], "parameter_types": [["Object"], ["Hash"]]}, "check_env": {"parameter_names": ["env"], "ret_types": ["nil"], "meth_source": "    def check_env(env)\n      ## The environment must be an instance of Hash that includes\n      ## CGI-like headers.  The application is free to modify the\n      ## environment.\n      assert(\"env #{env.inspect} is not a Hash, but #{env.class}\") {\n        env.kind_of? Hash\n      }\n\n      ##\n      ## The environment is required to include these variables\n      ## (adopted from PEP333), except when they'd be empty, but see\n      ## below.\n\n      ## <tt>REQUEST_METHOD</tt>:: The HTTP request method, such as\n      ##                           \"GET\" or \"POST\". This cannot ever\n      ##                           be an empty string, and so is\n      ##                           always required.\n\n      ## <tt>SCRIPT_NAME</tt>:: The initial portion of the request\n      ##                        URL's \"path\" that corresponds to the\n      ##                        application object, so that the\n      ##                        application knows its virtual\n      ##                        \"location\". This may be an empty\n      ##                        string, if the application corresponds\n      ##                        to the \"root\" of the server.\n\n      ## <tt>PATH_INFO</tt>:: The remainder of the request URL's\n      ##                      \"path\", designating the virtual\n      ##                      \"location\" of the request's target\n      ##                      within the application. This may be an\n      ##                      empty string, if the request URL targets\n      ##                      the application root and does not have a\n      ##                      trailing slash. This value may be\n      ##                      percent-encoded when originating from\n      ##                      a URL.\n\n      ## <tt>QUERY_STRING</tt>:: The portion of the request URL that\n      ##                         follows the <tt>?</tt>, if any. May be\n      ##                         empty, but is always required!\n\n      ## <tt>SERVER_NAME</tt>, <tt>SERVER_PORT</tt>::\n      ##                        When combined with <tt>SCRIPT_NAME</tt> and\n      ##                        <tt>PATH_INFO</tt>, these variables can be\n      ##                        used to complete the URL. Note, however,\n      ##                        that <tt>HTTP_HOST</tt>, if present,\n      ##                        should be used in preference to\n      ##                        <tt>SERVER_NAME</tt> for reconstructing\n      ##                        the request URL.\n      ##                        <tt>SERVER_NAME</tt> and <tt>SERVER_PORT</tt>\n      ##                        can never be empty strings, and so\n      ##                        are always required.\n\n      ## <tt>HTTP_</tt> Variables:: Variables corresponding to the\n      ##                            client-supplied HTTP request\n      ##                            headers (i.e., variables whose\n      ##                            names begin with <tt>HTTP_</tt>). The\n      ##                            presence or absence of these\n      ##                            variables should correspond with\n      ##                            the presence or absence of the\n      ##                            appropriate HTTP header in the\n      ##                            request. See\n      ##                            <a href=\"https://tools.ietf.org/html/rfc3875#section-4.1.18\">\n      ##                            RFC3875 section 4.1.18</a> for\n      ##                            specific behavior.\n\n      ## In addition to this, the Rack environment must include these\n      ## Rack-specific variables:\n\n      ## <tt>rack.version</tt>:: The Array representing this version of Rack\n      ##                         See Rack::VERSION, that corresponds to\n      ##                         the version of this SPEC.\n\n      ## <tt>rack.url_scheme</tt>:: +http+ or +https+, depending on the\n      ##                            request URL.\n\n      ## <tt>rack.input</tt>:: See below, the input stream.\n\n      ## <tt>rack.errors</tt>:: See below, the error stream.\n\n      ## <tt>rack.multithread</tt>:: true if the application object may be\n      ##                             simultaneously invoked by another thread\n      ##                             in the same process, false otherwise.\n\n      ## <tt>rack.multiprocess</tt>:: true if an equivalent application object\n      ##                              may be simultaneously invoked by another\n      ##                              process, false otherwise.\n\n      ## <tt>rack.run_once</tt>:: true if the server expects\n      ##                          (but does not guarantee!) that the\n      ##                          application will only be invoked this one\n      ##                          time during the life of its containing\n      ##                          process. Normally, this will only be true\n      ##                          for a server based on CGI\n      ##                          (or something similar).\n\n      ## <tt>rack.hijack?</tt>:: present and true if the server supports\n      ##                         connection hijacking. See below, hijacking.\n\n      ## <tt>rack.hijack</tt>:: an object responding to #call that must be\n      ##                        called at least once before using\n      ##                        rack.hijack_io.\n      ##                        It is recommended #call return rack.hijack_io\n      ##                        as well as setting it in env if necessary.\n\n      ## <tt>rack.hijack_io</tt>:: if rack.hijack? is true, and rack.hijack\n      ##                           has received #call, this will contain\n      ##                           an object resembling an IO. See hijacking.\n\n      ## Additional environment specifications have approved to\n      ## standardized middleware APIs.  None of these are required to\n      ## be implemented by the server.\n\n      ## <tt>rack.session</tt>:: A hash like interface for storing\n      ##                         request session data.\n      ##                         The store must implement:\n      if session = env[RACK_SESSION]\n        ##                         store(key, value)         (aliased as []=);\n        assert(\"session #{session.inspect} must respond to store and []=\") {\n          session.respond_to?(:store) && session.respond_to?(:[]=)\n        }\n\n        ##                         fetch(key, default = nil) (aliased as []);\n        assert(\"session #{session.inspect} must respond to fetch and []\") {\n          session.respond_to?(:fetch) && session.respond_to?(:[])\n        }\n\n        ##                         delete(key);\n        assert(\"session #{session.inspect} must respond to delete\") {\n          session.respond_to?(:delete)\n        }\n\n        ##                         clear;\n        assert(\"session #{session.inspect} must respond to clear\") {\n          session.respond_to?(:clear)\n        }\n      end\n\n      ## <tt>rack.logger</tt>:: A common object interface for logging messages.\n      ##                        The object must implement:\n      if logger = env[RACK_LOGGER]\n        ##                         info(message, &block)\n        assert(\"logger #{logger.inspect} must respond to info\") {\n          logger.respond_to?(:info)\n        }\n\n        ##                         debug(message, &block)\n        assert(\"logger #{logger.inspect} must respond to debug\") {\n          logger.respond_to?(:debug)\n        }\n\n        ##                         warn(message, &block)\n        assert(\"logger #{logger.inspect} must respond to warn\") {\n          logger.respond_to?(:warn)\n        }\n\n        ##                         error(message, &block)\n        assert(\"logger #{logger.inspect} must respond to error\") {\n          logger.respond_to?(:error)\n        }\n\n        ##                         fatal(message, &block)\n        assert(\"logger #{logger.inspect} must respond to fatal\") {\n          logger.respond_to?(:fatal)\n        }\n      end\n\n      ## <tt>rack.multipart.buffer_size</tt>:: An Integer hint to the multipart parser as to what chunk size to use for reads and writes.\n      if bufsize = env[RACK_MULTIPART_BUFFER_SIZE]\n        assert(\"rack.multipart.buffer_size must be an Integer > 0 if specified\") {\n          bufsize.is_a?(Integer) && bufsize > 0\n        }\n      end\n\n      ## <tt>rack.multipart.tempfile_factory</tt>:: An object responding to #call with two arguments, the filename and content_type given for the multipart form field, and returning an IO-like object that responds to #<< and optionally #rewind. This factory will be used to instantiate the tempfile for each multipart form file upload field, rather than the default class of Tempfile.\n      if tempfile_factory = env[RACK_MULTIPART_TEMPFILE_FACTORY]\n        assert(\"rack.multipart.tempfile_factory must respond to #call\") { tempfile_factory.respond_to?(:call) }\n        env[RACK_MULTIPART_TEMPFILE_FACTORY] = lambda do |filename, content_type|\n          io = tempfile_factory.call(filename, content_type)\n          assert(\"rack.multipart.tempfile_factory return value must respond to #<<\") { io.respond_to?(:<<) }\n          io\n        end\n      end\n\n      ## The server or the application can store their own data in the\n      ## environment, too.  The keys must contain at least one dot,\n      ## and should be prefixed uniquely.  The prefix <tt>rack.</tt>\n      ## is reserved for use with the Rack core distribution and other\n      ## accepted specifications and must not be used otherwise.\n      ##\n\n      %w[REQUEST_METHOD SERVER_NAME SERVER_PORT\n         QUERY_STRING\n         rack.version rack.input rack.errors\n         rack.multithread rack.multiprocess rack.run_once].each { |header|\n        assert(\"env missing required key #{header}\") { env.include? header }\n      }\n\n      ## The environment must not contain the keys\n      ## <tt>HTTP_CONTENT_TYPE</tt> or <tt>HTTP_CONTENT_LENGTH</tt>\n      ## (use the versions without <tt>HTTP_</tt>).\n      %w[HTTP_CONTENT_TYPE HTTP_CONTENT_LENGTH].each { |header|\n        assert(\"env contains #{header}, must use #{header[5,-1]}\") {\n          not env.include? header\n        }\n      }\n\n      ## The CGI keys (named without a period) must have String values.\n      env.each { |key, value|\n        next  if key.include? \".\"   # Skip extensions\n        assert(\"env variable #{key} has non-string value #{value.inspect}\") {\n          value.kind_of? String\n        }\n      }\n\n      ## There are the following restrictions:\n\n      ## * <tt>rack.version</tt> must be an array of Integers.\n      assert(\"rack.version must be an Array, was #{env[RACK_VERSION].class}\") {\n        env[RACK_VERSION].kind_of? Array\n      }\n      ## * <tt>rack.url_scheme</tt> must either be +http+ or +https+.\n      assert(\"rack.url_scheme unknown: #{env[RACK_URL_SCHEME].inspect}\") {\n        %w[http https].include?(env[RACK_URL_SCHEME])\n      }\n\n      ## * There must be a valid input stream in <tt>rack.input</tt>.\n      check_input env[RACK_INPUT]\n      ## * There must be a valid error stream in <tt>rack.errors</tt>.\n      check_error env[RACK_ERRORS]\n      ## * There may be a valid hijack stream in <tt>rack.hijack_io</tt>\n      check_hijack env\n\n      ## * The <tt>REQUEST_METHOD</tt> must be a valid token.\n      assert(\"REQUEST_METHOD unknown: #{env[REQUEST_METHOD]}\") {\n        env[REQUEST_METHOD] =~ /\\A[0-9A-Za-z!\\#$%&'*+.^_`|~-]+\\z/\n      }\n\n      ## * The <tt>SCRIPT_NAME</tt>, if non-empty, must start with <tt>/</tt>\n      assert(\"SCRIPT_NAME must start with /\") {\n        !env.include?(SCRIPT_NAME) ||\n        env[SCRIPT_NAME] == \"\" ||\n        env[SCRIPT_NAME] =~ /\\A\\//\n      }\n      ## * The <tt>PATH_INFO</tt>, if non-empty, must start with <tt>/</tt>\n      assert(\"PATH_INFO must start with /\") {\n        !env.include?(PATH_INFO) ||\n        env[PATH_INFO] == \"\" ||\n        env[PATH_INFO] =~ /\\A\\//\n      }\n      ## * The <tt>CONTENT_LENGTH</tt>, if given, must consist of digits only.\n      assert(\"Invalid CONTENT_LENGTH: #{env[\"CONTENT_LENGTH\"]}\") {\n        !env.include?(\"CONTENT_LENGTH\") || env[\"CONTENT_LENGTH\"] =~ /\\A\\d+\\z/\n      }\n\n      ## * One of <tt>SCRIPT_NAME</tt> or <tt>PATH_INFO</tt> must be\n      ##   set.  <tt>PATH_INFO</tt> should be <tt>/</tt> if\n      ##   <tt>SCRIPT_NAME</tt> is empty.\n      assert(\"One of SCRIPT_NAME or PATH_INFO must be set (make PATH_INFO '/' if SCRIPT_NAME is empty)\") {\n        env[SCRIPT_NAME] || env[PATH_INFO]\n      }\n      ##   <tt>SCRIPT_NAME</tt> never should be <tt>/</tt>, but instead be empty.\n      assert(\"SCRIPT_NAME cannot be '/', make it '' and PATH_INFO '/'\") {\n        env[SCRIPT_NAME] != \"/\"\n      }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 65], "parameter_types": [["Hash"]]}, "check_input": {"parameter_names": ["input"], "ret_types": ["nil"], "meth_source": "    def check_input(input)\n      ## When applicable, its external encoding must be \"ASCII-8BIT\" and it\n      ## must be opened in binary mode, for Ruby 1.9 compatibility.\n      assert(\"rack.input #{input} does not have ASCII-8BIT as its external encoding\") {\n        input.external_encoding.name == \"ASCII-8BIT\"\n      } if input.respond_to?(:external_encoding)\n      assert(\"rack.input #{input} is not opened in binary mode\") {\n        input.binmode?\n      } if input.respond_to?(:binmode?)\n\n      ## The input stream must respond to +gets+, +each+, +read+ and +rewind+.\n      [:gets, :each, :read, :rewind].each { |method|\n        assert(\"rack.input #{input} does not respond to ##{method}\") {\n          input.respond_to? method\n        }\n      }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 335], "parameter_types": [["Object"]]}, "check_content_length": {"parameter_names": ["status", "headers"], "ret_types": ["nil"], "meth_source": "    def check_content_length(status, headers)\n      headers.each { |key, value|\n        if key.downcase == 'content-length'\n          ## There must not be a <tt>Content-Length</tt> header when the\n          ## +Status+ is 1xx, 204, 205 or 304.\n          assert(\"Content-Length header found in #{status} response, not allowed\") {\n            not Rack::Utils::STATUS_WITH_NO_ENTITY_BODY.include? status.to_i\n          }\n          @content_length = value\n        end\n      }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 673], "parameter_types": [["Object"], ["Hash"]]}, "check_headers": {"parameter_names": ["header"], "ret_types": ["nil"], "meth_source": "    def check_headers(header)\n      ## The header must respond to +each+, and yield values of key and value.\n      assert(\"headers object should respond to #each, but doesn't (got #{header.class} as headers)\") {\n         header.respond_to? :each\n      }\n      header.each { |key, value|\n        ## Special headers starting \"rack.\" are for communicating with the\n        ## server, and must not be sent back to the client.\n        next if key =~ /^rack\\..+$/\n\n        ## The header keys must be Strings.\n        assert(\"header key must be a string, was #{key.class}\") {\n          key.kind_of? String\n        }\n        ## The header must not contain a +Status+ key.\n        assert(\"header must not contain Status\") { key.downcase != \"status\" }\n        ## The header must conform to RFC7230 token specification, i.e. cannot\n        ## contain non-printable ASCII, DQUOTE or \"(),/:;<=>?@[\\]{}\".\n        assert(\"invalid header name: #{key}\") { key !~ /[\\(\\),\\/:;<=>\\?@\\[\\\\\\]{}[:cntrl:]]/ }\n\n        ## The values of the header must be Strings,\n        assert(\"a header value must be a String, but the value of \" +\n          \"'#{key}' is a #{value.class}\") { value.kind_of? String }\n        ## consisting of lines (for multiple header values, e.g. multiple\n        ## <tt>Set-Cookie</tt> values) separated by \"\\\\n\".\n        value.split(\"\\n\").each { |item|\n          ## The lines must not contain characters below 037.\n          assert(\"invalid header value #{key}: #{item.inspect}\") {\n            item !~ /[\\000-\\037]/\n          }\n        }\n      }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 624], "parameter_types": [["Hash"]]}, "initialize": {"parameter_names": ["app"], "ret_types": ["Object"], "meth_source": "    def initialize(app)\n      @app = app\n      @content_length = nil\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 9], "parameter_types": [["Object"]]}, "check_error": {"parameter_names": ["error"], "ret_types": ["nil"], "meth_source": "    def check_error(error)\n      ## The error stream must respond to +puts+, +write+ and +flush+.\n      [:puts, :write, :flush].each { |method|\n        assert(\"rack.error #{error} does not respond to ##{method}\") {\n          error.respond_to? method\n        }\n      }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 455], "parameter_types": [["Object"]]}, "check_hijack_response": {"parameter_names": ["headers", "env"], "ret_types": ["nil"], "meth_source": "    def check_hijack_response(headers, env)\n\n      # this check uses headers like a hash, but the spec only requires\n      # headers respond to #each\n      headers = Rack::Utils::HeaderHash.new(headers)\n\n      ## In order to do this, an application may set the special header\n      ## <tt>rack.hijack</tt> to an object that responds to <tt>call</tt>\n      ## accepting an argument that conforms to the <tt>rack.hijack_io</tt>\n      ## protocol.\n      ##\n      ## After the headers have been sent, and this hijack callback has been\n      ## called, the application is now responsible for the remaining lifecycle\n      ## of the IO. The application is also responsible for maintaining HTTP\n      ## semantics. Of specific note, in almost all cases in the current SPEC,\n      ## applications will have wanted to specify the header Connection:close in\n      ## HTTP/1.1, and not Connection:keep-alive, as there is no protocol for\n      ## returning hijacked sockets to the web server. For that purpose, use the\n      ## body streaming API instead (progressively yielding strings via each).\n      ##\n      ## Servers must ignore the <tt>body</tt> part of the response tuple when\n      ## the <tt>rack.hijack</tt> response API is in use.\n\n      if env[RACK_IS_HIJACK] && headers[RACK_HIJACK]\n        assert('rack.hijack header must respond to #call') {\n          headers[RACK_HIJACK].respond_to? :call\n        }\n        original_hijack = headers[RACK_HIJACK]\n        headers[RACK_HIJACK] = proc do |io|\n          original_hijack.call HijackWrapper.new(io)\n        end\n      else\n        ##\n        ## The special response header <tt>rack.hijack</tt> must only be set\n        ## if the request env has <tt>rack.hijack?</tt> <tt>true</tt>.\n        assert('rack.hijack header must not be present if server does not support hijacking') {\n          headers[RACK_HIJACK].nil?\n        }\n      end\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 567], "parameter_types": [["Hash"], ["Hash"]]}, "call": {"parameter_names": ["env"], "ret_types": ["Array"], "meth_source": "    def call(env=nil)\n      dup._call(env)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 36], "parameter_types": [["Hash"]]}, "each": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def each\n      @closed = false\n      bytes = 0\n\n      ## The Body must respond to +each+\n      assert(\"Response body must respond to each\") do\n        @body.respond_to?(:each)\n      end\n\n      @body.each { |part|\n        ## and must only yield String values.\n        assert(\"Body yielded non-string value #{part.inspect}\") {\n          part.kind_of? String\n        }\n        bytes += part.bytesize\n        yield part\n      }\n      verify_content_length(bytes)\n\n      ##\n      ## The Body itself should not be an instance of String, as this will\n      ## break in Ruby 1.9.\n      ##\n      ## If the Body responds to +close+, it will be called after iteration. If\n      ## the body is replaced by a middleware after action, the original body\n      ## must be closed first, if it responds to close.\n      # XXX howto: assert(\"Body has not been closed\") { @closed }\n\n\n      ##\n      ## If the Body responds to +to_path+, it must return a String\n      ## identifying the location of a file whose contents are identical\n      ## to that produced by calling +each+; this may be used by the\n      ## server as an alternative, possibly more efficient way to\n      ## transport the response.\n\n      if @body.respond_to?(:to_path)\n        assert(\"The file identified by body.to_path does not exist\") {\n          ::File.exist? @body.to_path\n        }\n      end\n\n      ##\n      ## The Body commonly is an Array of Strings, the application\n      ## instance itself, or a File-like object.\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 699], "parameter_types": []}, "_call": {"parameter_names": ["env"], "ret_types": ["Array"], "meth_source": "    def _call(env)\n      ## It takes exactly one argument, the *environment*\n      assert(\"No env given\") { env }\n      check_env env\n\n      env[RACK_INPUT] = InputWrapper.new(env[RACK_INPUT])\n      env[RACK_ERRORS] = ErrorWrapper.new(env[RACK_ERRORS])\n\n      ## and returns an Array of exactly three values:\n      status, headers, @body = @app.call(env)\n      ## The *status*,\n      check_status status\n      ## the *headers*,\n      check_headers headers\n\n      check_hijack_response headers, env\n\n      ## and the *body*.\n      check_content_type status, headers\n      check_content_length status, headers\n      @head_request = env[REQUEST_METHOD] == HEAD\n      [status, headers, self]\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 40], "parameter_types": [["Hash"]]}, "close": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "    def close\n      @closed = true\n      @body.close  if @body.respond_to?(:close)\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/lint.rb", 746], "parameter_types": []}}, "Rack::Session::Cookie::Identity": {"decode": {"parameter_names": ["str"], "ret_types": ["String"], "meth_source": "        def decode(str); str; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/cookie.rb", 101], "parameter_types": [["String"]]}, "encode": {"parameter_names": ["str"], "ret_types": ["String"], "meth_source": "        def encode(str); str; end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/session/cookie.rb", 100], "parameter_types": [["String"]]}}, "Rack::Server": {"check_pid!": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "      def check_pid!\n        case pidfile_process_status\n        when :running, :not_owned\n          $stderr.puts \"A server is already running. Check #{options[:pid]}.\"\n          exit(1)\n        when :dead\n          ::File.delete(options[:pid])\n        end\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 368], "parameter_types": []}, "daemonize_app": {"parameter_names": [], "ret_types": ["Integer"], "meth_source": "      def daemonize_app\n        Process.daemon\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 356], "parameter_types": []}, "app": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "    def app\n      @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 217], "parameter_types": []}, "start": {"parameter_names": ["blk"], "ret_types": ["nil"], "meth_source": "    def start &blk\n      if options[:warn]\n        $-w = true\n      end\n\n      if includes = options[:include]\n        $LOAD_PATH.unshift(*includes)\n      end\n\n      if library = options[:require]\n        require library\n      end\n\n      if options[:debug]\n        $DEBUG = true\n        require 'pp'\n        p options[:server]\n        pp wrapped_app\n        pp app\n      end\n\n      check_pid! if options[:pid]\n\n      # Touch the wrapped app, so that the config.ru is loaded before\n      # daemonization (i.e. before chdir, etc).\n      wrapped_app\n\n      daemonize_app if options[:daemonize]\n\n      write_pid if options[:pid]\n\n      trap(:INT) do\n        if server.respond_to?(:shutdown)\n          server.shutdown\n        else\n          exit\n        end\n      end\n\n      server.run wrapped_app, options, &blk\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 257], "parameter_types": [["Proc"]]}, "pidfile_process_status": {"parameter_names": [], "ret_types": ["Symbol"], "meth_source": "      def pidfile_process_status\n        return :exited unless ::File.exist?(options[:pid])\n\n        pid = ::File.read(options[:pid]).to_i\n        return :dead if pid == 0\n\n        Process.kill(0, pid)\n        :running\n      rescue Errno::ESRCH\n        :dead\n      rescue Errno::EPERM\n        :not_owned\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 378], "parameter_types": []}, "opt_parser": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      def opt_parser\n        Options.new\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 338], "parameter_types": []}, "build_app": {"parameter_names": ["app"], "ret_types": ["Object"], "meth_source": "      def build_app(app)\n        middleware[options[:environment]].reverse_each do |middleware|\n          middleware = middleware.call(self) if middleware.respond_to?(:call)\n          next unless middleware\n          klass, *args = middleware\n          app = klass.new(app, *args)\n        end\n        app\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 342], "parameter_types": [["Object"]]}, "initialize": {"parameter_names": ["options"], "ret_types": ["Object"], "meth_source": "    def initialize(options = nil)\n      @ignore_options = []\n\n      if options\n        @use_default_options = false\n        @options = options\n        @app = options[:app] if options[:app]\n      else\n        argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV\n        @use_default_options = true\n        @options = parse_options(argv)\n      end\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 184], "parameter_types": [["Hash"]]}, "wrapped_app": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      def wrapped_app\n        @wrapped_app ||= build_app app\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 352], "parameter_types": []}, "server": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "    def server\n      @_server ||= Rack::Handler.get(options[:server])\n\n      unless @_server\n        @_server = Rack::Handler.default\n\n        # We already speak FastCGI\n        @ignore_options = [:File, :Port] if @_server.to_s == 'Rack::Handler::FastCGI'\n      end\n\n      @_server\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 299], "parameter_types": []}, "build_app_from_string": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      def build_app_from_string\n        Rack::Builder.new_from_string(self.options[:builder])\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 323], "parameter_types": []}, "parse_options": {"parameter_names": ["args"], "ret_types": ["Object"], "meth_source": "      def parse_options(args)\n        # Don't evaluate CGI ISINDEX parameters.\n        # http://www.meb.uni-bonn.de/docs/cgi/cl.html\n        args.clear if ENV.include?(REQUEST_METHOD)\n\n        @options = opt_parser.parse!(args)\n        @options[:config] = ::File.expand_path(options[:config])\n        ENV[\"RACK_ENV\"] = options[:environment]\n        @options\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 327], "parameter_types": [["Array"]]}, "default_options": {"parameter_names": [], "ret_types": ["Hash"], "meth_source": "    def default_options\n      environment  = ENV['RACK_ENV'] || 'development'\n      default_host = environment == 'development' ? 'localhost' : '0.0.0.0'\n\n      {\n        :environment => environment,\n        :pid         => nil,\n        :Port        => 9292,\n        :Host        => default_host,\n        :AccessLog   => [],\n        :config      => \"config.ru\"\n      }\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 203], "parameter_types": []}, "write_pid": {"parameter_names": [], "ret_types": ["nil"], "meth_source": "      def write_pid\n        ::File.open(options[:pid], ::File::CREAT | ::File::EXCL | ::File::WRONLY ){ |f| f.write(\"#{Process.pid}\") }\n        at_exit { ::File.delete(options[:pid]) if ::File.exist?(options[:pid]) }\n      rescue Errno::EEXIST\n        check_pid!\n        retry\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 360], "parameter_types": []}, "middleware": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "    def middleware\n      self.class.middleware\n    end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 253], "parameter_types": []}, "build_app_and_options_from_config": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "      def build_app_and_options_from_config\n        if !::File.exist? options[:config]\n          abort \"configuration #{options[:config]} not found\"\n        end\n\n        app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)\n        @options.merge!(options) { |key, old, new| old }\n        app\n      end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/server.rb", 313], "parameter_types": []}}, "Rack::Multipart::Parser::Collector": {"initialize": {"parameter_names": ["tempfile"], "ret_types": ["Object"], "meth_source": "        def initialize tempfile\n          @tempfile = tempfile\n          @mime_parts = []\n          @open_files = 0\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 121], "parameter_types": [["Object"]]}, "on_mime_body": {"parameter_names": ["mime_index", "content"], "ret_types": ["nil"], "meth_source": "        def on_mime_body mime_index, content\n          @mime_parts[mime_index].body << content\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 146], "parameter_types": [["Integer"], ["String"]]}, "on_mime_head": {"parameter_names": ["mime_index", "head", "filename", "content_type", "name"], "ret_types": ["nil"], "meth_source": "        def on_mime_head mime_index, head, filename, content_type, name\n          if filename\n            body = @tempfile.call(filename, content_type)\n            body.binmode if body.respond_to?(:binmode)\n            klass = TempfilePart\n            @open_files += 1\n          else\n            body = ''.force_encoding(Encoding::ASCII_8BIT)\n            klass = BufferPart\n          end\n\n          @mime_parts[mime_index] = klass.new(body, head, filename, content_type, name)\n          check_open_files\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 131], "parameter_types": [["Integer"], ["Object"], ["String"], ["String"], ["String"]]}, "check_open_files": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "        def check_open_files\n          if Utils.multipart_part_limit > 0\n            if @open_files >= Utils.multipart_part_limit\n              @mime_parts.each(&:close)\n              raise MultipartPartLimitError, 'Maximum file multiparts in content reached'\n            end\n          end\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 155], "parameter_types": []}, "on_mime_finish": {"parameter_names": ["mime_index"], "ret_types": ["nil"], "meth_source": "        def on_mime_finish mime_index\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 150], "parameter_types": [["Integer"]]}, "each": {"parameter_names": [], "ret_types": ["Object"], "meth_source": "        def each\n          @mime_parts.each { |part| yield part }\n        end\n", "source_location": ["/Users/cassidy/.rvm/gems/ruby-2.3.0/gems/rack-2.0.1/lib/rack/multipart/parser.rb", 127], "parameter_types": []}}}